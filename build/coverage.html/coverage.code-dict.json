{"/home/travis/build/npmtest/node-npmtest-autocannon/test.js":"/* istanbul instrument in package npmtest_autocannon */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-autocannon/lib.npmtest_autocannon.js":"/* istanbul instrument in package npmtest_autocannon */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_autocannon = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_autocannon = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-autocannon/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-autocannon && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_autocannon */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_autocannon\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_autocannon.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_autocannon.rollup.js'] =\n            local.assetsDict['/assets.npmtest_autocannon.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_autocannon.__dirname + '/lib.npmtest_autocannon.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-autocannon/node_modules/autocannon/autocannon.js":"#! /usr/bin/env node\n\n'use strict'\n\nconst minimist = require('minimist')\nconst fs = require('fs')\nconst path = require('path')\nconst help = fs.readFileSync(path.join(__dirname, 'help.txt'), 'utf8')\nconst run = require('./lib/run')\nconst track = require('./lib/progressTracker')\n\nmodule.exports = run\nmodule.exports.track = track\n\nmodule.exports.start = start\nmodule.exports.parseArguments = parseArguments\n\nfunction parseArguments (argvs) {\n  const argv = minimist(argvs, {\n    boolean: ['json', 'n', 'help', 'renderLatencyTable', 'renderProgressBar', 'forever', 'idReplacement'],\n    alias: {\n      connections: 'c',\n      pipelining: 'p',\n      timeout: 't',\n      duration: 'd',\n      amount: 'a',\n      json: 'j',\n      renderLatencyTable: ['l', 'latency'],\n      method: 'm',\n      headers: ['H', 'header'],\n      body: 'b',\n      bailout: 'B',\n      input: 'i',\n      maxConnectionRequests: 'M',\n      maxOverallRequests: 'O',\n      connectionRate: 'r',\n      overallRate: 'R',\n      reconnectRate: 'D',\n      renderProgressBar: 'progress',\n      title: 'T',\n      version: 'v',\n      forever: 'f',\n      idReplacement: 'I',\n      help: 'h'\n    },\n    default: {\n      connections: 10,\n      timeout: 10,\n      pipelining: 1,\n      duration: 10,\n      reconnectRate: 0,\n      renderLatencyTable: false,\n      renderProgressBar: true,\n      json: false,\n      forever: false,\n      method: 'GET',\n      idReplacement: false\n    }\n  })\n\n  argv.url = argv._[0]\n\n  // support -n to disable the progress bar and results table\n  if (argv.n) {\n    argv.renderProgressBar = false\n    argv.renderResultsTable = false\n  }\n\n  if (argv.version) {\n    console.log('autocannon', 'v' + require('./package').version)\n    console.log('node', process.version)\n    return\n  }\n\n  if (!argv.url || argv.help) {\n    console.error(help)\n    return\n  }\n\n  if (argv.input) {\n    argv.body = fs.readFileSync(argv.input)\n  }\n\n  if (argv.headers) {\n    if (!Array.isArray(argv.headers)) {\n      argv.headers = [argv.headers]\n    }\n\n    argv.headers = argv.headers.reduce((obj, header) => {\n      const index = header.indexOf('=')\n      obj[header.slice(0, index)] = header.slice(index + 1)\n      return obj\n    }, {})\n  }\n\n  return argv\n}\n\nfunction start (argv) {\n  if (!argv) {\n    // we are printing the help\n    return\n  }\n\n  const tracker = run(argv)\n\n  tracker.on('done', (result) => {\n    if (argv.json) {\n      console.log(JSON.stringify(result))\n    }\n  })\n\n  tracker.on('error', (err) => {\n    if (err) {\n      throw err\n    }\n  })\n\n  // if not rendering json, or if std isn't a tty, track progress\n  if (!argv.json || !process.stdout.isTTY) track(tracker, argv)\n\n  process.once('SIGINT', () => {\n    tracker.stop()\n  })\n}\n\nif (require.main === module) {\n  start(parseArguments(process.argv.slice(2)))\n}\n","/home/travis/build/npmtest/node-npmtest-autocannon/node_modules/autocannon/lib/run.js":"'use strict'\n\nconst EE = require('events').EventEmitter\nconst URL = require('url')\nconst Histogram = require('native-hdr-histogram')\nconst timestring = require('timestring')\nconst Client = require('./httpClient')\nconst xtend = require('xtend')\nconst histUtil = require('hdr-histogram-percentiles-obj')\nconst reInterval = require('reinterval')\nconst histAsObj = histUtil.histAsObj\nconst addPercentiles = histUtil.addPercentiles\n\nconst defaultOptions = {\n  headers: {},\n  body: new Buffer(0),\n  method: 'GET',\n  duration: 10,\n  connections: 10,\n  pipelining: 1,\n  timeout: 10,\n  maxConnectionRequests: 0,\n  maxOverallRequests: 0,\n  connectionRate: 0,\n  overallRate: 0,\n  amount: 0,\n  reconnectRate: 0,\n  forever: false,\n  idReplacement: false,\n  requests: [{}]\n}\n\nfunction run (opts, cb) {\n  const cbPassedIn = (typeof cb === 'function')\n\n  cb = cb || noop\n\n  const tracker = new EE()\n\n  const latencies = new Histogram(1, 10000, 5)\n  const requests = new Histogram(1, 1000000, 3)\n  const throughput = new Histogram(1, 100000000000, 1)\n  const statusCodes = [\n    0, // 1xx\n    0, // 2xx\n    0, // 3xx\n    0, // 4xx\n    0  // 5xx\n  ]\n\n  opts = xtend(defaultOptions, opts)\n\n  // do error checking, if error, return\n  if (checkOptsForErrors()) return\n\n  // set tracker.opts here, so throwing over invalid opts and setting defaults etc.\n  // is done\n  tracker.opts = opts\n\n  if (opts.url.indexOf('http') !== 0) opts.url = 'http://' + opts.url\n  const url = URL.parse(opts.url)\n\n  let counter = 0\n  let bytes = 0\n  let errors = 0\n  let timeouts = 0\n  let totalBytes = 0\n  let totalRequests = 0\n  let totalCompletedRequests = 0\n  let amount = opts.amount\n  let stop = false\n  let restart = true\n  let numRunning = opts.connections\n  let startTime = Date.now()\n\n  // copy over fields so that the client\n  // performs the right HTTP requests\n  url.pipelining = opts.pipelining\n  url.method = opts.method\n  url.body = opts.body\n  url.headers = opts.headers\n  url.setupClient = opts.setupClient\n  url.timeout = opts.timeout\n  url.requests = opts.requests\n  url.reconnectRate = opts.reconnectRate\n  url.responseMax = amount || opts.maxConnectionRequests || opts.maxOverallRequests\n  url.rate = opts.connectionRate || opts.overallRate\n  url.idReplacement = opts.idReplacement\n\n  let clients = []\n  initialiseClients(clients)\n\n  if (!amount) {\n    var stopTimer = setTimeout(() => {\n      stop = true\n    }, opts.duration * 1000)\n  }\n\n  tracker.stop = () => {\n    stop = true\n    restart = false\n  }\n\n  const interval = reInterval(tickInterval, 1000)\n\n  // put the start emit in a setImmediate so trackers can be added, etc.\n  setImmediate(() => { tracker.emit('start') })\n\n  function tickInterval () {\n    totalBytes += bytes\n    totalCompletedRequests += counter\n    requests.record(counter)\n    throughput.record(bytes)\n    counter = 0\n    bytes = 0\n    tracker.emit('tick')\n\n    if (stop) {\n      if (stopTimer) clearTimeout(stopTimer)\n      interval.clear()\n      clients.forEach((client) => client.destroy())\n      let result = {\n        title: opts.title,\n        url: opts.url,\n        requests: histAsObj(requests, totalCompletedRequests),\n        latency: addPercentiles(latencies, histAsObj(latencies)),\n        throughput: histAsObj(throughput, totalBytes),\n        errors: errors,\n        timeouts: timeouts,\n        duration: Math.round((Date.now() - startTime) / 1000),\n        start: new Date(startTime),\n        finish: new Date(),\n        connections: opts.connections,\n        pipelining: opts.pipelining,\n        'non2xx': statusCodes[0] + statusCodes[2] + statusCodes[3] + statusCodes[4]\n      }\n      result.requests.sent = totalRequests\n      statusCodes.forEach((code, index) => { result[(index + 1) + 'xx'] = code })\n\n      tracker.emit('done', result)\n      if (!opts.forever) cb(null, result)\n\n      // the restart function\n      setImmediate(() => {\n        if (opts.forever && restart) {\n          stop = false\n          stopTimer = setTimeout(() => {\n            stop = true\n          }, opts.duration * 1000)\n          errors = 0\n          timeouts = 0\n          totalBytes = 0\n          totalRequests = 0\n          totalCompletedRequests = 0\n          statusCodes.fill(0)\n          requests.reset()\n          latencies.reset()\n          throughput.reset()\n          startTime = Date.now()\n\n          // reinitialise clients\n          clients = []\n          initialiseClients(clients)\n\n          interval.reschedule(1000)\n          tracker.emit('start')\n        }\n      })\n    }\n  }\n\n  function initialiseClients (clients) {\n    for (let i = 0; i < opts.connections; i++) {\n      if (!amount && !opts.maxConnectionRequests && opts.maxOverallRequests) {\n        url.responseMax = distributeNums(opts.maxOverallRequests, i)\n      }\n      if (amount) {\n        url.responseMax = distributeNums(amount, i)\n      }\n      if (!opts.connectionRate && opts.overallRate) {\n        url.rate = distributeNums(opts.overallRate, i)\n      }\n\n      let client = new Client(url)\n      client.on('response', onResponse)\n      client.on('connError', onError)\n      client.on('timeout', onTimeout)\n      client.on('request', () => { totalRequests++ })\n      client.on('done', onDone)\n      clients.push(client)\n\n      // we will miss the initial request emits because the client emits request on construction\n      totalRequests += url.pipelining < url.rate ? url.rate : url.pipelining\n    }\n\n    function distributeNums (x, i) {\n      return (Math.floor(x / opts.connections) + (((i + 1) <= (x % opts.connections)) ? 1 : 0))\n    }\n\n    function onResponse (statusCode, resBytes, responseTime) {\n      tracker.emit('response', this, statusCode, resBytes, responseTime)\n      const codeIndex = Math.floor(parseInt(statusCode) / 100) - 1\n      statusCodes[codeIndex] += 1\n      // only record 2xx latencies\n      if (codeIndex === 1) latencies.record(responseTime)\n      bytes += resBytes\n      counter++\n    }\n\n    function onError () {\n      for (let i = 0; i < opts.pipelining; i++) tracker.emit('reqError')\n      errors++\n      if (opts.bailout && errors >= opts.bailout) stop = true\n    }\n\n    // treat a timeout as a special type of error\n    function onTimeout () {\n      for (let i = 0; i < opts.pipelining; i++) tracker.emit('reqError')\n      errors++\n      timeouts++\n      if (opts.bailout && errors >= opts.bailout) stop = true\n    }\n\n    function onDone () {\n      if (!--numRunning) stop = true\n    }\n  }\n\n  // will return true if error with opts entered\n  function checkOptsForErrors () {\n    if (!opts.url) {\n      errorCb(new Error('url option required'))\n      return true\n    }\n\n    if (typeof opts.duration === 'string') {\n      if (/[a-zA-Z]/.exec(opts.duration)) opts.duration = timestring(opts.duration)\n      else opts.duration = Number(opts.duration.trim())\n    }\n\n    if (typeof opts.duration === 'number') {\n      if (lessThanZeroError(opts.duration, 'duration')) return true\n    } else {\n      errorCb(new Error('duration entered was in an invalid format'))\n      return true\n    }\n\n    if (lessThanOneError(opts.connections, 'connections')) return true\n    if (lessThanOneError(opts.pipelining, 'pipelining factor')) return true\n    if (greaterThanZeroError(opts.timeout, 'timeout')) return true\n    if (opts.bailout && lessThanOneError(opts.bailout, 'bailout threshold')) return true\n    if (opts.connectionRate && lessThanOneError(opts.connectionRate, 'connectionRate')) return true\n    if (opts.overallRate && lessThanOneError(opts.overallRate, 'bailout overallRate')) return true\n    if (opts.amount && lessThanOneError(opts.amount, 'amount')) return true\n    if (opts.maxConnectionRequests && lessThanOneError(opts.maxConnectionRequests, 'maxConnectionRequests')) return true\n    if (opts.maxOverallRequests && lessThanOneError(opts.maxOverallRequests, 'maxOverallRequests')) return true\n\n    if (opts.forever && cbPassedIn) {\n      errorCb(new Error('should not use the callback parameter when the `forever` option is set to true. Use the `done` event on this event emitter'))\n      return true\n    }\n\n    function lessThanZeroError (x, label) {\n      if (x < 0) {\n        errorCb(new Error(`${label} can not be less than 0`))\n        return true\n      }\n      return false\n    }\n\n    function lessThanOneError (x, label) {\n      if (x < 1) {\n        errorCb(new Error(`${label} can not be less than 1`))\n        return true\n      }\n      return false\n    }\n\n    function greaterThanZeroError (x, label) {\n      if (x <= 0) {\n        errorCb(new Error(`${label} must be greater than 0`))\n        return true\n      }\n      return false\n    }\n\n    function errorCb (error) {\n      if (cbPassedIn) {\n        cb(error)\n      } else {\n        // wrapped in setImmediate so any error event handlers that are added to\n        // the tracker can be added before being emitted\n        setImmediate(() => { tracker.emit('error', error) })\n      }\n    }\n\n    return false\n  } // checkOptsForErrors\n\n  return tracker\n} // run\n\nfunction noop () {}\n\nmodule.exports = run\n","/home/travis/build/npmtest/node-npmtest-autocannon/node_modules/autocannon/lib/httpClient.js":"'use strict'\n\nconst inherits = require('util').inherits\nconst EE = require('events').EventEmitter\nconst net = require('net')\nconst tls = require('tls')\nconst retimer = require('retimer')\nconst HTTPParser = require('http-parser-js').HTTPParser\nconst RequestIterator = require('./requestIterator')\n\nfunction Client (opts) {\n  if (!(this instanceof Client)) {\n    return new Client(opts)\n  }\n  opts.setupClient = opts.setupClient || noop\n  opts.pipelining = opts.pipelining || 1\n  opts.port = opts.port || 80\n\n  this.opts = opts\n  this.timeout = (opts.timeout || 10) * 1000\n  this.secure = opts.protocol === 'https:'\n  if (this.secure && this.opts.port === 80) this.opts.port = 443\n  this.parser = new HTTPParser(HTTPParser.RESPONSE)\n  this.requestIterator = new RequestIterator(opts.requests, opts)\n\n  this.reqsMade = 0\n\n  // used for request limiting\n  this.responseMax = opts.responseMax\n\n  // used for rate limiting\n  this.reqsMadeThisSecond = 0\n  this.rate = opts.rate\n\n  // used for forcing reconnects\n  this.reconnectRate = opts.reconnectRate\n\n  this.resData = new Array(opts.pipelining)\n  for (var i = 0; i < this.resData.length; i++) {\n    this.resData[i] = {\n      bytes: 0,\n      headers: {},\n      startTime: [0, 0]\n    }\n  }\n\n  // cer = current expected response\n  this.cer = 0\n  this.destroyed = false\n\n  opts.setupClient(this)\n\n  const handleTimeout = () => {\n    // all pipelined requests have timed out here\n    this.resData.forEach(() => this.emit('timeout'))\n    this.cer = 0\n    this._destroyConnection()\n\n    // timeout has already occured, need to set a new timeoutTicker\n    this.timeoutTicker = retimer(handleTimeout, this.timeout)\n\n    this._connect()\n  }\n\n  if (this.rate) {\n    this.rateInterval = setInterval(() => {\n      this.reqsMadeThisSecond = 0\n      if (this.paused) this._doRequest(this.cer)\n      this.paused = false\n    }, 1000)\n  }\n\n  this.timeoutTicker = retimer(handleTimeout, this.timeout)\n  this.parser[HTTPParser.kOnHeaders] = () => {}\n  this.parser[HTTPParser.kOnHeadersComplete] = (opts) => {\n    this.emit('headers', opts)\n    this.resData[this.cer].headers = opts\n  }\n\n  this.parser[HTTPParser.kOnBody] = (body) => {\n    this.emit('body', body)\n  }\n\n  this.parser[HTTPParser.kOnMessageComplete] = () => {\n    let end = process.hrtime(this.resData[this.cer].startTime)\n    let responseTime = end[0] * 1e3 + end[1] / 1e6\n    this.emit('response', this.resData[this.cer].headers.statusCode, this.resData[this.cer].bytes, responseTime)\n    this.resData[this.cer].bytes = 0\n\n    if (!this.destroyed && this.reconnectRate && this.reqsMade % this.reconnectRate === 0) {\n      return this._resetConnection()\n    }\n\n    this.cer = this.cer === opts.pipelining - 1 ? 0 : this.cer++\n    this._doRequest(this.cer)\n  }\n\n  this._connect()\n}\n\ninherits(Client, EE)\n\nClient.prototype._connect = function () {\n  if (this.secure) {\n    this.conn = tls.connect(this.opts.port, this.opts.hostname, { rejectUnauthorized: false })\n  } else {\n    this.conn = net.connect(this.opts.port, this.opts.hostname)\n  }\n\n  this.conn.on('error', (error) => {\n    this.emit('connError', error)\n    if (!this.destroyed) this._connect()\n  })\n\n  this.conn.on('data', (chunk) => {\n    this.resData[this.cer].bytes += chunk.length\n    this.parser.execute(chunk)\n  })\n\n  this.conn.on('end', () => {\n    if (!this.destroyed) this._connect()\n  })\n\n  for (let i = 0; i < this.opts.pipelining; i++) {\n    this._doRequest(i)\n  }\n}\n\n// rpi = request pipelining index\nClient.prototype._doRequest = function (rpi) {\n  if (!this.rate || (this.rate && this.reqsMadeThisSecond++ < this.rate)) {\n    if (!this.destroyed && this.responseMax && this.reqsMade >= this.responseMax) {\n      return this.destroy()\n    }\n    this.emit('request')\n    this.resData[rpi].startTime = process.hrtime()\n    this.conn.write(this.requestIterator.move())\n    this.timeoutTicker.reschedule(this.timeout)\n    this.reqsMade++\n  } else {\n    this.paused = true\n  }\n}\n\nClient.prototype._resetConnection = function () {\n  this._destroyConnection()\n  this._connect()\n}\n\nClient.prototype._destroyConnection = function () {\n  this.conn.removeAllListeners('error')\n  this.conn.removeAllListeners('end')\n  this.conn.on('error', () => {})\n  this.conn.destroy()\n}\n\nClient.prototype.destroy = function () {\n  if (!this.destroyed) {\n    this.destroyed = true\n    this.timeoutTicker.clear()\n    if (this.rate) clearInterval(this.rateInterval)\n    this.emit('done')\n    this._destroyConnection()\n  }\n}\n\nClient.prototype.getRequestBuffer = function (newHeaders) {\n  return this.requestIterator.currentRequest.requestBuffer\n}\n\nClient.prototype.setHeaders = function (newHeaders) {\n  this._okayToUpdateCheck()\n  this.requestIterator.setHeaders(newHeaders)\n}\n\nClient.prototype.setBody = function (newBody) {\n  this._okayToUpdateCheck()\n  this.requestIterator.setBody(newBody)\n}\n\nClient.prototype.setHeadersAndBody = function (newHeaders, newBody) {\n  this._okayToUpdateCheck()\n  this.requestIterator.setHeadersAndBody(newHeaders, newBody)\n}\n\nClient.prototype.setRequest = function (newRequest) {\n  this._okayToUpdateCheck()\n  this.requestIterator.setRequest(newRequest)\n}\n\nClient.prototype.setRequests = function (newRequests) {\n  this._okayToUpdateCheck()\n  this.requestIterator.setRequests(newRequests)\n}\n\nClient.prototype._okayToUpdateCheck = function () {\n  if (this.opts.pipelining > 1) {\n    throw new Error('cannot update requests when the piplining factor is greater than 1')\n  }\n}\n\nfunction noop () {}\n\nmodule.exports = Client\n","/home/travis/build/npmtest/node-npmtest-autocannon/node_modules/autocannon/lib/requestIterator.js":"'use strict'\n\nconst hyperid = require('hyperid')(true)\nconst inherits = require('util').inherits\nconst requestBuilder = require('./httpRequestBuilder')\n\nfunction RequestIterator (requests, defaults) {\n  if (!(this instanceof RequestIterator)) {\n    return new RequestIterator(requests, defaults)\n  }\n\n  this.reqDefaults = defaults\n  this.requestBuilder = requestBuilder(defaults)\n  this.setRequests(requests)\n}\n\ninherits(RequestIterator, Object)\n\nRequestIterator.prototype.nextRequest = function () {\n  ++this.currentRequestIndex\n  this.currentRequestIndex = this.currentRequestIndex < this.requests.length ? this.currentRequestIndex : 0\n  this.currentRequest = this.requests[this.currentRequestIndex]\n  return this.currentRequest\n}\n\nRequestIterator.prototype.nextRequestBuffer = function () {\n  // get next request\n  this.nextRequest()\n  return this.currentRequest.requestBuffer\n}\n\nRequestIterator.prototype.move = function () {\n  // get the current buffer and proceed to next request\n  let ret = this.currentRequest.requestBuffer\n  this.nextRequest()\n  return this.reqDefaults.idReplacement\n    ? new Buffer(ret.toString().replace(/\\[<id>\\]/g, hyperid()))\n    : ret\n}\n\nRequestIterator.prototype.setRequests = function (newRequests) {\n  this.requests = newRequests || [{}]\n  this.currentRequestIndex = 0\n  this.currentRequest = this.requests[0]\n  this.rebuildRequests()\n}\n\nRequestIterator.prototype.rebuildRequests = function () {\n  this.requests.forEach((request) => {\n    request.requestBuffer = this.requestBuilder(request)\n  })\n}\n\nRequestIterator.prototype.setHeaders = function (newHeaders) {\n  this.currentRequest.headers = newHeaders || {}\n  this.rebuildRequest()\n}\n\nRequestIterator.prototype.setBody = function (newBody) {\n  this.currentRequest.body = newBody || new Buffer(0)\n  this.rebuildRequest()\n}\n\nRequestIterator.prototype.setHeadersAndBody = function (newHeaders, newBody) {\n  this.currentRequest.headers = newHeaders || {}\n  this.currentRequest.body = newBody || new Buffer(0)\n  this.rebuildRequest()\n}\n\nRequestIterator.prototype.setRequest = function (newRequest) {\n  this.currentRequest = newRequest || {}\n  this.rebuildRequest()\n}\n\nRequestIterator.prototype.rebuildRequest = function () {\n  this.currentRequest.requestBuffer = this.requestBuilder(this.currentRequest)\n  this.requests[this.currentRequestIndex] = this.currentRequest\n}\n\nmodule.exports = RequestIterator\n","/home/travis/build/npmtest/node-npmtest-autocannon/node_modules/autocannon/lib/httpRequestBuilder.js":"'use strict'\n\nconst xtend = require('xtend')\nconst methods = require('./httpMethods')\n\n// this is a build request factory, that curries the build request function\n// and sets the default for it\nfunction requestBuilder (defaults) {\n  // these need to be defined per request builder creation, because of the way\n  // headers don't get deep copied\n  const builderDefaults = {\n    method: 'GET',\n    path: '/',\n    headers: {},\n    body: new Buffer(0),\n    hostname: 'localhost',\n    port: 80\n  }\n\n  defaults = xtend(builderDefaults, defaults)\n\n  // buildRequest takes an object, and turns it into a buffer representing the\n  // http request\n  return function buildRequest (reqData) {\n    // below is a hack to enable deep extending of the headers so the default\n    // headers object isn't overwritten by accident\n    reqData = reqData || {}\n    reqData.headers = xtend(defaults.headers, reqData.headers)\n\n    reqData = xtend(defaults, reqData)\n    // for some reason some tests fail with method === undefined\n    // the reqData.method should be set to SOMETHING in this case\n    // cannot find reason for failure if `|| 'GET'` is taken out\n    const method = reqData.method\n    const path = reqData.path\n    const headers = reqData.headers\n    const body = reqData.body\n\n    let host = reqData.host\n    if (!host) {\n      const hostname = reqData.hostname\n      const port = reqData.port\n      host = hostname + ':' + port\n    }\n\n    if (methods.indexOf(method) < 0) {\n      throw new Error(`${method} HTTP method is not supported`)\n    }\n\n    const baseReq = `${method} ${path} HTTP/1.1\\r\\nHost: ${host}\\r\\nConnection: keep-alive\\r\\n`\n\n    let bodyBuf\n\n    if (typeof body === 'string') {\n      bodyBuf = new Buffer(body)\n    } else if (Buffer.isBuffer(body)) {\n      bodyBuf = body\n    } else if (body) {\n      throw new Error('body must be either a string or a buffer')\n    }\n\n    if (bodyBuf && bodyBuf.length > 0) {\n      const idCount = reqData.idReplacement\n        ? (bodyBuf.toString().match(/\\[<id>\\]/g) || []).length\n        : 0\n      headers['Content-Length'] = `${bodyBuf.length + (idCount * 27)}`\n    }\n\n    let req = Object.keys(headers)\n      .map((key) => `${key}: ${headers[key]}\\r\\n`)\n      .reduce((acc, str) => acc + str, baseReq)\n\n    req = new Buffer(req + '\\r\\n', 'utf8')\n\n    if (bodyBuf && bodyBuf.length > 0) {\n      req = Buffer.concat([req, bodyBuf, new Buffer('\\r\\n')])\n    }\n\n    return req\n  }\n}\n\nmodule.exports = requestBuilder\n","/home/travis/build/npmtest/node-npmtest-autocannon/node_modules/autocannon/lib/httpMethods.js":"// most http methods taken from RFC 7231\n// PATCH is defined in RFC 5789\nmodule.exports = [\n  'GET',\n  'HEAD',\n  'POST',\n  'PUT',\n  'DELETE',\n  'CONNECT',\n  'OPTIONS',\n  'TRACE',\n  'PATCH'\n]\n","/home/travis/build/npmtest/node-npmtest-autocannon/node_modules/autocannon/lib/progressTracker.js":"'use strict'\n\nconst ProgressBar = require('progress')\nconst table = require('table').table\nconst getBorderCharacters = require('table').getBorderCharacters\nconst Chalk = require('chalk')\nconst testColorSupport = require('color-support')\nconst prettyBytes = require('pretty-bytes')\nconst xtend = require('xtend')\nconst format = require('./format')\nconst percentiles = require('hdr-histogram-percentiles-obj').percentiles\nconst defaults = {\n  // use stderr as its progressBar's default\n  outputStream: process.stderr,\n  renderProgressBar: true,\n  renderResultsTable: true,\n  renderLatencyTable: false\n}\n\nfunction track (instance, opts) {\n  if (!instance) {\n    throw new Error('instance required for tracking')\n  }\n\n  opts = xtend(defaults, opts)\n\n  const chalk = new Chalk.constructor({ enabled: testColorSupport({ stream: opts.outputStream }) })\n  // this default needs to be set after chalk is setup, because chalk is now local to this func\n  opts.progressBarString = opts.progressBarString || `${chalk.green('running')} [:bar] :percent`\n\n  const iOpts = instance.opts\n  let durationProgressBar\n  let amountProgressBar\n\n  instance.on('start', () => {\n    if (opts.renderProgressBar) {\n      let msg = `${iOpts.connections} connections`\n\n      if (iOpts.pipelining > 1) {\n        msg += ` with ${iOpts.pipelining} pipelining factor`\n      }\n\n      if (!iOpts.amount) {\n        logToStream(`Running ${iOpts.duration}s test @ ${iOpts.url}\\n${msg}\\n`)\n\n        durationProgressBar = trackDuration(instance, opts, iOpts)\n      } else {\n        logToStream(`Running ${iOpts.amount} requests test @ ${iOpts.url}\\n${msg}\\n`)\n\n        amountProgressBar = trackAmount(instance, opts, iOpts)\n      }\n    }\n  })\n\n  // add listeners for progress bar to instance here so they aren't\n  // added on restarting, causing listener leaks\n  // note: Attempted to curry the functions below, but that breaks the functionality\n  // as they use the scope/closure of the progress bar variables to allow them to be reset\n  if (opts.renderProgressBar && opts.outputStream.isTTY) {\n    if (!iOpts.amount) { // duration progress bar\n      instance.on('tick', () => { durationProgressBar.tick() })\n      instance.on('done', () => { durationProgressBar.tick(iOpts.duration - 1) })\n      process.once('SIGINT', () => { durationProgressBar.tick(iOpts.duration - 1) })\n    } else { // amount progress bar\n      instance.on('response', () => { amountProgressBar.tick() })\n      instance.on('reqError', () => { amountProgressBar.tick() })\n      instance.on('done', () => { amountProgressBar.tick(iOpts.amount - 1) })\n      process.once('SIGINT', () => { amountProgressBar.tick(iOpts.amount - 1) })\n    }\n  }\n\n  instance.on('done', (result) => {\n    // the code below this `if` just renders the results table...\n    // if the user doesn't want to render the table, we can just return early\n    if (!opts.renderResultsTable) return\n\n    const out = table([\n      asColor(chalk.cyan, ['Stat', 'Avg', 'Stdev', 'Max']),\n      asRow(chalk.bold('Latency (ms)'), result.latency),\n      asRow(chalk.bold('Req/Sec'), result.requests),\n      asRow(chalk.bold('Bytes/Sec'), asBytes(result.throughput))\n    ], {\n      border: getBorderCharacters('void'),\n      columnDefault: {\n        paddingLeft: 0,\n        paddingRight: 1\n      },\n      drawHorizontalLine: () => false\n    })\n\n    logToStream(out)\n\n    if (opts.renderLatencyTable) {\n      const latency = table([\n        asColor(chalk.cyan, ['Percentile', 'Latency (ms)'])\n      ].concat(percentiles.map((perc) => {\n        const key = ('p' + perc).replace('.', '')\n        return [\n          chalk.bold('' + perc),\n          result.latency[key]\n        ]\n      })), {\n        border: getBorderCharacters('void'),\n        columnDefault: {\n          paddingLeft: 0,\n          paddingRight: 6\n        },\n        drawHorizontalLine: () => false\n      })\n\n      logToStream(latency)\n    }\n\n    if (result.non2xx) {\n      logToStream(`${result['2xx']} 2xx responses, ${result.non2xx} non 2xx responses`)\n    }\n    logToStream(`${format(result.requests.total)} requests in ${result.duration}s, ${prettyBytes(result.throughput.total)} read`)\n    if (result.errors) {\n      logToStream(`${format(result.errors)} errors (${format(result.timeouts)} timeouts)`)\n    }\n  })\n\n  function logToStream (msg) {\n    opts.outputStream.write(msg + '\\n')\n  }\n}\n\nfunction trackDuration (instance, opts, iOpts) {\n  // if switch needed needed to avoid\n  // https://github.com/mcollina/autocannon/issues/60\n  if (!opts.outputStream.isTTY) return\n\n  const progressBar = new ProgressBar(opts.progressBarString, {\n    width: 20,\n    incomplete: ' ',\n    total: iOpts.duration,\n    clear: true,\n    stream: opts.outputStream\n  })\n\n  progressBar.tick(0)\n  return progressBar\n}\n\nfunction trackAmount (instance, opts, iOpts) {\n  // if switch needed needed to avoid\n  // https://github.com/mcollina/autocannon/issues/60\n  if (!opts.outputStream.isTTY) return\n\n  const progressBar = new ProgressBar(opts.progressBarString, {\n    width: 20,\n    incomplete: ' ',\n    total: iOpts.amount,\n    clear: true,\n    stream: opts.outputStream\n  })\n\n  progressBar.tick(0)\n  return progressBar\n}\n\nfunction asRow (name, stat) {\n  return [\n    name,\n    stat.average,\n    stat.stddev,\n    stat.max\n  ]\n}\n\nfunction asColor (colorise, row) {\n  return row.map((entry) => colorise(entry))\n}\n\nfunction asBytes (stat) {\n  const result = Object.create(stat)\n  result.average = prettyBytes(stat.average)\n  result.stddev = prettyBytes(stat.stddev)\n  result.max = prettyBytes(stat.max)\n  result.min = prettyBytes(stat.min)\n  return result\n}\n\nmodule.exports = track\n","/home/travis/build/npmtest/node-npmtest-autocannon/node_modules/autocannon/lib/format.js":"'use strict'\n\nfunction format (num) {\n  if (num < 1000) {\n    return '' + num\n  } else {\n    return '' + Math.round(num / 1000) + 'k'\n  }\n}\n\nmodule.exports = format\n","/home/travis/build/npmtest/node-npmtest-autocannon/node_modules/autocannon/for-zero-x.js":"'use strict'\n\nconst autocannon = require('.')\n\nautocannon({\n  url: 'http://localhost:3000',\n  connections: 10,\n  duration: 10\n}, console.log)\n","/home/travis/build/npmtest/node-npmtest-autocannon/node_modules/autocannon/server.js":"'use strict'\n\nconst http = require('http')\nconst https = require('https')\nconst fs = require('fs')\nconst path = require('path')\n\nconst options = {\n  key: fs.readFileSync(path.join(__dirname, 'test', '/key.pem')),\n  cert: fs.readFileSync(path.join(__dirname, 'test', '/cert.pem')),\n  passphrase: 'test'\n}\nconst server = http.createServer(handle)\nconst server2 = https.createServer(options, handle)\n\nserver.listen(3000)\nserver2.listen(3001)\n\nfunction handle (req, res) {\n  res.end('hello world')\n}\n","/home/travis/build/npmtest/node-npmtest-autocannon/node_modules/autocannon/samples/customise-individual-connection.js":"'use strict'\n\nconst http = require('http')\nconst autocannon = require('autocannon')\n\nconst server = http.createServer(handle)\n\nserver.listen(0, startBench)\n\nfunction handle (req, res) {\n  res.end('hello world')\n}\n\nfunction startBench () {\n  const url = 'http://localhost:' + server.address().port\n\n  autocannon({\n    url: url,\n    connections: 1000,\n    duration: 10,\n    setupClient: setupClient\n  }, finishedBench)\n\n  let connection = 0\n\n  function setupClient (client) {\n    client.setBody('connection number', connection++)\n  }\n\n  function finishedBench (err, res) {\n    console.log('finished bench', err, res)\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-autocannon/node_modules/autocannon/samples/modifying-request.js":"'use strict'\n\nconst http = require('http')\nconst autocannon = require('autocannon')\n\nconst server = http.createServer(handle)\n\nserver.listen(0, startBench)\n\nfunction handle (req, res) {\n  res.end('hello world')\n}\n\nfunction startBench () {\n  const url = 'http://localhost:' + server.address().port\n\n  const instance = autocannon({\n    url: url,\n    connections: 1000,\n    duration: 10\n  }, finishedBench)\n\n  let message = 0\n  // modify the body on future requests\n  instance.on('response', function (client, statusCode, returnBytes, responseTime) {\n    client.setBody('message ' + message++)\n  })\n\n  let headers = 0\n  // modify the headers on future requests\n  // this wipes any existing headers out with the new ones\n  instance.on('response', function (client, statusCode, returnBytes, responseTime) {\n    var newHeaders = {}\n    newHeaders[`header${headers++}`] = `headerValue${headers++}`\n    client.setHeaders(newHeaders)\n  })\n\n  function finishedBench (err, res) {\n    console.log('finished bench', err, res)\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-autocannon/node_modules/autocannon/samples/requests-sample.js":"'use strict'\n\nconst http = require('http')\nconst autocannon = require('autocannon')\n\nconst server = http.createServer(handle)\n\nserver.listen(0, startBench)\n\nfunction handle (req, res) {\n  res.end('hello world')\n}\n\nfunction startBench () {\n  const url = 'http://localhost:' + server.address().port\n\n  autocannon({\n    url: url,\n    connections: 1000,\n    duration: 10,\n    headers: {\n      // by default we add an auth token to all requests\n      auth: 'A Pregenerated auth token'\n    },\n    requests: [\n      {\n        method: 'POST', // this should be a post for logging in\n        path: '/login',\n        body: 'valid login details',\n        // overwrite our default headers,\n        // so we don't add an auth token\n        // for this request\n        headers: {}\n      },\n      {\n        path: '/mySecretDetails'\n        // this will automatically add the pregenerated auth token\n      },\n      {\n        method: 'PUT', // this should be a put for modifying secret details\n        path: '/mySecretDetails',\n        headers: { // let submit some json?\n          'Content-type': 'application/json; charset=utf-8'\n        },\n        // we need to stringify the json first\n        body: JSON.stringify({\n          name: 'my new name'\n        })\n      }\n    ]\n  }, finishedBench)\n\n  function finishedBench (err, res) {\n    console.log('finished bench', err, res)\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-autocannon/node_modules/autocannon/samples/track-run.js":"'use strict'\n\nconst http = require('http')\nconst autocannon = require('autocannon')\n\nconst server = http.createServer(handle)\n\nserver.listen(0, startBench)\n\nfunction handle (req, res) {\n  res.end('hello world')\n}\n\nfunction startBench () {\n  const instance = autocannon({\n    url: 'http://localhost:' + server.address().port\n  }, finishedBench)\n\n  autocannon.track(instance)\n\n  // this is used to kill the instance on CTRL-C\n  process.once('SIGINT', () => {\n    instance.stop()\n  })\n\n  function finishedBench (err, res) {\n    console.log('finished bench', err, res)\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-autocannon/node_modules/autocannon/samples/using-id-replacement.js":"'use strict'\n\nconst http = require('http')\nconst autocannon = require('autocannon')\n\nconst server = http.createServer(handle)\n\nserver.listen(0, startBench)\n\nfunction handle (req, res) {\n  res.end('hello world')\n}\n\nfunction startBench () {\n  const url = 'http://localhost:' + server.address().port\n\n  autocannon({\n    url: url,\n    connections: 1000,\n    duration: 10,\n    requests: [\n      {\n        method: 'POST',\n        path: '/register',\n        headers: {\n          'Content-type': 'application/json; charset=utf-8'\n        },\n        body: JSON.stringify({\n          name: 'New User',\n          email: 'new-[<id>]@user.com' // [<id>] will be replaced with generated HyperID at run time\n        })\n      }\n    ],\n    idReplacement: true\n  }, finishedBench)\n\n  function finishedBench (err, res) {\n    console.log('finished bench', err, res)\n  }\n}\n"}